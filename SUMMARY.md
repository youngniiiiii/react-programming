# 8. 16




# 8. 14

## 컴포넌트 상태 관리 요약

1. JavaScript 로컬 변수를 사용하면 React 컴포넌트 상태 관리가 가능하지 않습니다.
1. React가 제공하는 useState 훅을 사용해야 상태 관리가 가능합니다.
1. useState 훅은 배열을 반환하는데 첫번째 항목은 상태, 두번째 항목은 상태 업데이트 함수입니다.
1. useState 훅이 반환한 상태 업데이트 함수가 실행되면 React에게 렌더 트리거(render trigger) 합니다.
1. 렌더 트리거는 컴포넌트를 다시 실행시킵니다. (리-렌더링 발생)
1. 일반 로컬 변수는 함수 재실행 과정에서 초기화되지만, useState에서 추출된 상태는 이전의 값을 기억합니다.
1. 컴포넌트 내부에서 상태를 관리하는 것이 가능합니다. useState 훅을 사용해 여러 상태를 관리할 수 있습니다.
1. 상태 업데이트 함수는 사용법이 2가지인데 하나는 다음 상태(nextState) 값을 직접 전달하는 것이고, 다른 하나는 [set 함수](https://react.dev/reference/react/useState#setstate)를 사용하는 것입니다.
1. set 함수를 사용한 업데이트는 이전 상태 값을 토대로 계산된 다음 상태 값을 반환해야 합니다.

## 사이드 이펙트 요약

1. 렌더링 단계(렌더 트리거 → 컴포넌트 렌더링 → DOM 커밋) 중 DOM 커밋 시점에 실행(콜백)되는 로직에서는 사이드 이펙트 처리 가능
1. 사이드 이펙트는 DOM 커밋 이후에 실행되어야 한다. (접근성, 요소의 스타일 변경, 모든 명령형 프로그래밍 코드)
1. 사이드 이펙트 로직을 허용하는 영역은 2가지 (이벤트 핸들러, useEffect 훅의 이펙트 콜백 함수)

## 컴포넌트 순수성 유지 요약

1. 컴포넌트 렌더링 단계에 영향을 미치지 않도록 순수함을 유지해야 합니다.
1. 사이드 이펙트(부수 효과)를 유발하는 코드를 함수 몸체(body) 안에 작성해서는 안됩니다.
1. 동일 입력, 동일 출력을 지켜야 합니다. (props(읽기 전용) → JSX 반환)
1. StrictMode 컴포넌트의 역햘은 계산이 순수한지 확인하는 것입니다. (2번씩 렌더링)
1. StrictMode는 배포(production) 모드에서 제거되므로 성능에 영향을 주지 않습니다.
1. 로컬 뮤테이션은 컴포넌트 함수 내부에서 이뤄져도 문제가 되지 않습니다.


# 8. 11

## CSS 모듈 요약

1. CSS 클래스 코드를 모듈 객체로 받아와 고유한 이름을 사용할 수 있습니다.
1. 다른 사람이 작성한 클래스 이름과 절대로 충돌할 일이 없다.
1. 컴포넌트 스타일을 보호할 수 있다.
1. 사용자 정의 클래스 모듈 이름을 설정할 수 있다. ([참고](https://vitejs.dev/config/shared-options.html#css-modules))

## 이벤트 핸들링 요약

1. 리액트 컴포넌트에 이벤트 연결하기 (`onclick` ❌, `onClick` ✅)
1. 모든 props를 예측해서 컴포넌트에 적용하기란 쉽지 않다. (그래서 `restProps`를 활용)
1. 이벤트 핸들러(리스너) 로직 구성 (DOM 스크립팅 → 사이드 이펙트, 불순 함수 허용)
1. 사이드 이펙트란? React 렌더링 과정과 관련 없는 것들(부수적인 것)을 말합니다.

# 8. 10

## 리스트 렌더링 요약

1. 배열 순환 리스트 렌더링
1. 배열 역순으로 정렬한 다음 리스트 렌더링 (원본 배열을 변경하면 안됨, 배열 복사 또는 새로운 배열 반환 메서드)
1. 객체 순환 리스트 렌더링 (객체 → 배열 객체로 변경 → map 메서드로 순환)
1. `<dl>` 내부에 `<div>`를 사용하는 것이 적절한 지 고민한 후 적절하지 않으면 `<></>`를 사용 
1. `<></>`의 경우 리스트 렌더링 시 `key` prop을 설정할 수 없음. 그러므로 `<React.Fragment key={} />` 활용해야 함